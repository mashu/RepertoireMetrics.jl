var documenterSearchIndex = {"docs":
[{"location":"metrics/#Diversity-and-Clonality-Metrics","page":"Metrics","title":"Diversity and Clonality Metrics","text":"This page provides detailed explanations of all metrics implemented in RepertoireMetrics.jl, including mathematical formulas, interpretation, and usage guidelines.","category":"section"},{"location":"metrics/#Quick-Reference:-Which-Metric-Should-I-Use?","page":"Metrics","title":"Quick Reference: Which Metric Should I Use?","text":"Your Question Recommended Metrics Why\nHow many unique clones? Richness, Chao1 Chao1 estimates unseen clones\nIs the repertoire clonally expanded? Clonality, Gini, D50 Directly measure dominance\nHow diverse overall? Shannon Diversity, Inverse Simpson Effective number of clones\nHow dominant is the top clone? Berger-Parker, D50 Simple, interpretable\nComparing samples of different sizes? Simpson, Berger-Parker, or use rarefaction Less sample-size sensitive\nFull diversity profile? Hill numbers with varying q Unified theoretical framework","category":"section"},{"location":"metrics/#Common-Pitfalls","page":"Metrics","title":"Common Pitfalls","text":"Pitfall Problem Solution\nComparing richness across sample sizes Larger samples always show more clones Use rarefaction or Chao1\nIgnoring rare clones Simpson/Berger-Parker may miss important rare populations Also compute Shannon or richness\nOver-interpreting small differences Sampling noise can be substantial Use confidence intervals or bootstrapping\nAssuming one metric tells the whole story Different metrics capture different aspects Report multiple complementary metrics","category":"section"},{"location":"metrics/#Metric-Relationships","page":"Metrics","title":"Metric Relationships","text":"Clonality = 1 - Evenness = 1 - (Shannon Entropy / log(Richness))\nShannon Diversity = exp(Shannon Entropy) = Hill number q=1\nInverse Simpson = 1 / Simpson Index = Hill number q=2\n\n","category":"section"},{"location":"metrics/#Notation","page":"Metrics","title":"Notation","text":"Throughout this document:\n\nS = number of unique lineages (richness)\nN = total count (sequences or cells)\nn_i = count of lineage i\np_i = n_i  N = relative frequency of lineage i\nf_k = number of lineages with exactly k sequences (frequency of frequencies)","category":"section"},{"location":"metrics/#Basic-Counts","page":"Metrics","title":"Basic Counts","text":"","category":"section"},{"location":"metrics/#Richness-(S)","page":"Metrics","title":"Richness (S)","text":"Formula:\n\nS = sum_i=1^S mathbf1n_i  0\n\nInterpretation: The total number of unique lineages observed in the repertoire. This is the simplest measure of diversity—more lineages means more diverse.\n\nLimitations: Richness is highly sensitive to sample size. Larger samples almost always have higher richness, making direct comparisons difficult without rarefaction.\n\nUse when: You want a basic count of unique clones, especially when comparing samples of similar size.","category":"section"},{"location":"metrics/#Total-Count-(N)","page":"Metrics","title":"Total Count (N)","text":"Formula:\n\nN = sum_i=1^S n_i\n\nInterpretation: The total number of sequences or cells in the repertoire. Essential for normalization and understanding sampling depth.\n\n","category":"section"},{"location":"metrics/#Shannon-Entropy-Family","page":"Metrics","title":"Shannon Entropy Family","text":"","category":"section"},{"location":"metrics/#Shannon-Entropy-(H)","page":"Metrics","title":"Shannon Entropy (H)","text":"Formula:\n\nH = -sum_i=1^S p_i log(p_i)\n\nwhere we use the convention that 0 log(0) = 0.\n\nInterpretation: Shannon entropy quantifies the uncertainty in predicting the lineage of a randomly selected sequence. Higher entropy means more uncertainty, indicating a more diverse repertoire.\n\nRange: 0 log(S)\n\nH = 0 when one lineage dominates completely\nH = log(S) when all lineages are equally abundant\n\nProperties:\n\nUses natural logarithm (nats), though log₂ (bits) is also common\nSensitive to rare lineages but less so than richness\nAffected by both richness and evenness","category":"section"},{"location":"metrics/#Shannon-Diversity-(Exponential-of-H)","page":"Metrics","title":"Shannon Diversity (Exponential of H)","text":"Formula:\n\n^1D = e^H = expleft(-sum_i=1^S p_i log(p_i)right)\n\nInterpretation: The \"effective number of lineages\"—how many equally abundant lineages would produce the same entropy. Also known as the Hill number of order 1.\n\nRange: 1 S\n\n^1D = 1 for a single dominant lineage\n^1D = S for perfect evenness\n\nWhy use this over raw entropy? Shannon diversity is in interpretable units (number of lineages) rather than abstract entropy units.","category":"section"},{"location":"metrics/#Normalized-Shannon-Entropy","page":"Metrics","title":"Normalized Shannon Entropy","text":"Formula:\n\nH_norm = fracHlog(S) = fracHH_max\n\nInterpretation: Shannon entropy scaled to [0, 1]. Represents how close the distribution is to maximum entropy (perfect evenness).\n\nRange: 0 1\n\nH_norm = 0 for a single dominant lineage\nH_norm = 1 for perfect evenness","category":"section"},{"location":"metrics/#Clonality","page":"Metrics","title":"Clonality","text":"Formula:\n\ntextClonality = 1 - H_norm = 1 - fracHlog(S)\n\nInterpretation: The complement of normalized Shannon entropy. High clonality indicates oligoclonal expansion—a repertoire dominated by few lineages.\n\nRange: 0 1\n\ntextClonality = 0 for perfect evenness (maximally polyclonal)\ntextClonality = 1 for a single lineage (monoclonal)\n\nUse when: Investigating antigen-driven clonal expansion, disease states, or immune responses.","category":"section"},{"location":"metrics/#Evenness-(Pielou's-J)","page":"Metrics","title":"Evenness (Pielou's J)","text":"Formula:\n\nJ = fracHlog(S) = H_norm\n\nInterpretation: Identical to normalized Shannon entropy. Measures how evenly sequences are distributed among lineages, independent of richness.\n\nRange: 0 1\n\nJ = 0 for maximum unevenness\nJ = 1 for perfect evenness\n\nNote: Evenness = 1 - Clonality.\n\n","category":"section"},{"location":"metrics/#Simpson-Family","page":"Metrics","title":"Simpson Family","text":"","category":"section"},{"location":"metrics/#Simpson's-Index-(D)","page":"Metrics","title":"Simpson's Index (D)","text":"Formula:\n\nD = sum_i=1^S p_i^2\n\nInterpretation: The probability that two randomly selected sequences belong to the same lineage. Higher D means less diversity (more concentrated).\n\nRange: 1S 1\n\nD = 1S for perfect evenness\nD = 1 for a single lineage\n\nNote: This is sometimes called Simpson's concentration index.","category":"section"},{"location":"metrics/#Simpson's-Diversity-(Gini-Simpson-Index)","page":"Metrics","title":"Simpson's Diversity (Gini-Simpson Index)","text":"Formula:\n\n1 - D = 1 - sum_i=1^S p_i^2\n\nInterpretation: The probability that two randomly selected sequences belong to different lineages. Higher values indicate more diversity.\n\nRange: 0 1 - 1S\n\n1 - D to 0 as repertoire becomes monoclonal\n1 - D to 1 as repertoire becomes maximally diverse","category":"section"},{"location":"metrics/#Inverse-Simpson-(Hill-Number-q2)","page":"Metrics","title":"Inverse Simpson (Hill Number q=2)","text":"Formula:\n\n^2D = frac1D = frac1sum_i=1^S p_i^2\n\nInterpretation: The \"effective number of lineages\" when weighted by frequency squared. Emphasizes dominant lineages more than Shannon diversity.\n\nRange: 1 S\n\n^2D = 1 for a single lineage\n^2D = S for perfect evenness\n\nUse when: You want a diversity measure less sensitive to rare lineages than Shannon entropy.\n\n","category":"section"},{"location":"metrics/#Dominance-Metrics","page":"Metrics","title":"Dominance Metrics","text":"","category":"section"},{"location":"metrics/#Berger-Parker-Index","page":"Metrics","title":"Berger-Parker Index","text":"Formula:\n\nd = p_max = max_i(p_i)\n\nInterpretation: The relative frequency of the most abundant lineage. A simple measure of dominance.\n\nRange: 1S 1\n\nd = 1S for perfect evenness\nd = 1 when one lineage has all sequences\n\nUse when: You want a simple, interpretable measure of how dominant the top clone is.","category":"section"},{"location":"metrics/#D50","page":"Metrics","title":"D50","text":"Formula:\n\nD50 = minleftk  sum_i=1^k p_(i) geq 05right\n\nwhere p_(1) geq p_(2) geq cdots are frequencies sorted in descending order.\n\nInterpretation: The minimum number of lineages needed to account for 50% of the repertoire. Low D50 indicates high clonality (few lineages dominate).\n\nRange: 1 lceil S2 rceil\n\nD50 = 1 when the top lineage has ≥50% of sequences\nD50 = lceil S2 rceil for perfect evenness\n\nUse when: You want an intuitive measure of how \"top-heavy\" the distribution is.\n\n","category":"section"},{"location":"metrics/#Inequality-Metrics","page":"Metrics","title":"Inequality Metrics","text":"","category":"section"},{"location":"metrics/#Gini-Coefficient","page":"Metrics","title":"Gini Coefficient","text":"Formula:\n\nG = fracsum_i=1^S sum_j=1^S p_i - p_j2S sum_i=1^S p_i = frac2sum_i=1^S i cdot p_(i)S - fracS+1S\n\nwhere p_(1) leq p_(2) leq cdots are frequencies sorted in ascending order.\n\nInterpretation: Measures inequality in lineage abundances. Originally developed for economic inequality (wealth distribution).\n\nRange: 0 1\n\nG = 0 for perfect equality (all lineages equal)\nG to 1 for maximum inequality\n\nGeometric interpretation: Half the relative mean absolute difference between all pairs of lineages.\n\nUse when: You want to quantify how unequally sequences are distributed, independent of richness.\n\n","category":"section"},{"location":"metrics/#Richness-Estimators","page":"Metrics","title":"Richness Estimators","text":"","category":"section"},{"location":"metrics/#Chao1","page":"Metrics","title":"Chao1","text":"Formula:\n\nhatS_Chao1 = S_obs + fracf_1^22 f_2\n\nwhere:\n\nS_obs = observed richness\nf_1 = number of singletons (lineages with count = 1)\nf_2 = number of doubletons (lineages with count = 2)\n\nIf f_2 = 0, use the bias-corrected formula:\n\nhatS_Chao1 = S_obs + fracf_1(f_1 - 1)2\n\nInterpretation: Estimates the true number of lineages, including those not observed due to sampling limitations. Based on the idea that rare species inform us about unobserved species.\n\nRange: S_obs infty)\n\nUse when: You suspect many rare lineages exist that weren't sampled, and want to estimate true richness.\n\n","category":"section"},{"location":"metrics/#Hill-Numbers-(Unified-Framework)","page":"Metrics","title":"Hill Numbers (Unified Framework)","text":"","category":"section"},{"location":"metrics/#Definition","page":"Metrics","title":"Definition","text":"Formula:\n\n^qD = left(sum_i=1^S p_i^qright)^1(1-q)\n\nSpecial cases:\n\nOrder Formula Interpretation\nq = 0 ^0D = S Richness\nq to 1 ^1D = e^H exp(Shannon entropy)\nq = 2 ^2D = 1D Inverse Simpson\nq to infty ^infty D = 1p_max Reciprocal of Berger-Parker\n\nInterpretation: Hill numbers provide a unified framework for diversity. The order q controls sensitivity to rare vs. common lineages:\n\nLow q: More sensitive to rare lineages\nHigh q: More sensitive to dominant lineages\n\nUse when: You want to explore the full diversity profile of a repertoire, or need a theoretically grounded framework that unifies different diversity measures.\n\n","category":"section"},{"location":"metrics/#Comparing-Metrics","page":"Metrics","title":"Comparing Metrics","text":"","category":"section"},{"location":"metrics/#Relationship-Between-Diversity-and-Clonality","page":"Metrics","title":"Relationship Between Diversity and Clonality","text":"Aspect Diversity Metrics Clonality Metrics\nFocus Variability Dominance\nHigh value Polyclonal Oligoclonal\nExamples Shannon diversity, Inverse Simpson Clonality, Gini, D50 (inverse)\n\nKey relationships:\n\nClonality = 1 - Evenness\nShannon Diversity = exp(Shannon Entropy)\nInverse Simpson = 1 / Simpson Index","category":"section"},{"location":"metrics/#Sensitivity-to-Different-Features","page":"Metrics","title":"Sensitivity to Different Features","text":"Metric Sensitive to rare lineages Sensitive to dominant lineages Sensitive to sample size\nRichness Very high Low Very high\nShannon Entropy Moderate Moderate Moderate\nSimpson Index Low High Low\nBerger-Parker Very low Very high Low\nChao1 Very high Low High","category":"section"},{"location":"metrics/#Recommendations","page":"Metrics","title":"Recommendations","text":"For comparing samples of different sizes: Use rarefaction first, or use metrics less sensitive to sample size (Simpson, Berger-Parker). See the Rarefaction section in the Quick Start guide.\nFor detecting clonal expansion: Use Clonality, Gini, D50, or Berger-Parker.\nFor a complete picture: Compute multiple metrics or use the Hill number profile across different orders.\nFor estimating true diversity: Use Chao1, especially when many singletons are present.\nFor robust comparisons without rarefaction: Prefer Simpson diversity or Inverse Simpson, which are naturally dominated by abundant lineages and less affected by sampling depth.","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Lineage-Definition-Strategies","page":"API Reference","title":"Lineage Definition Strategies","text":"","category":"section"},{"location":"api/#Data-Structures","page":"API Reference","title":"Data Structures","text":"","category":"section"},{"location":"api/#Reading-Data","page":"API Reference","title":"Reading Data","text":"","category":"section"},{"location":"api/#Computing-Metrics","page":"API Reference","title":"Computing Metrics","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Individual-Metric-Functions","page":"API Reference","title":"Individual Metric Functions","text":"","category":"section"},{"location":"api/#Hill-Numbers","page":"API Reference","title":"Hill Numbers","text":"","category":"section"},{"location":"api/#Composable-Metric-Selection","page":"API Reference","title":"Composable Metric Selection","text":"","category":"section"},{"location":"api/#Predefined-Metric-Sets","page":"API Reference","title":"Predefined Metric Sets","text":"","category":"section"},{"location":"api/#Metric-Types","page":"API Reference","title":"Metric Types","text":"","category":"section"},{"location":"api/#Sampling","page":"API Reference","title":"Sampling","text":"","category":"section"},{"location":"api/#Exporting-Results","page":"API Reference","title":"Exporting Results","text":"","category":"section"},{"location":"api/#Length-Statistics","page":"API Reference","title":"Length Statistics","text":"","category":"section"},{"location":"api/#Types-and-Functions","page":"API Reference","title":"Types and Functions","text":"","category":"section"},{"location":"api/#Composable-Length-Metrics","page":"API Reference","title":"Composable Length Metrics","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#RepertoireMetrics.AbstractLineageDefinition","page":"API Reference","title":"RepertoireMetrics.AbstractLineageDefinition","text":"AbstractLineageDefinition\n\nAbstract supertype for all lineage definition strategies. Concrete subtypes define how sequences are grouped into clonal lineages.\n\nImplementing a new strategy\n\nTo implement a new lineage definition strategy:\n\nCreate a subtype of AbstractLineageDefinition\nImplement lineage_key(strategy, row) returning a hashable key\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.LineageIDDefinition","page":"API Reference","title":"RepertoireMetrics.LineageIDDefinition","text":"LineageIDDefinition <: AbstractLineageDefinition\n\nDefine lineages using the lineage_id column directly. This is the simplest strategy when lineage assignment has already been performed.\n\nFields\n\ncolumn::Symbol: Column name containing lineage IDs (default: :lineage_id)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.VJCdr3Definition","page":"API Reference","title":"RepertoireMetrics.VJCdr3Definition","text":"VJCdr3Definition <: AbstractLineageDefinition\n\nDefine lineages using the combination of V gene, J gene, and CDR3 sequence. This is consistent with LineageCollapse.jl's default behavior.\n\nFields\n\nv_column::Symbol: Column name for V gene call (default: :v_call)\nj_column::Symbol: Column name for J gene call (default: :j_call)\ncdr3_column::Symbol: Column name for CDR3 sequence (default: :cdr3)\nuse_first_allele::Bool: Use only first allele from calls (default: true)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.CustomDefinition","page":"API Reference","title":"RepertoireMetrics.CustomDefinition","text":"CustomDefinition{F} <: AbstractLineageDefinition\n\nDefine lineages using a custom function that extracts a key from each row.\n\nFields\n\nkey_func::F: Function row -> key that returns a hashable lineage key\n\nExample\n\n# Group by V gene family only\nstrategy = CustomDefinition(row -> first(split(string(row.v_call), \"-\")))\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.lineage_key","page":"API Reference","title":"RepertoireMetrics.lineage_key","text":"lineage_key(strategy::AbstractLineageDefinition, row) -> key\n\nExtract a lineage key from a data row using the given strategy. Returns a hashable value that identifies the lineage.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.first_allele","page":"API Reference","title":"RepertoireMetrics.first_allele","text":"first_allele(call::AbstractString) -> String\n\nExtract the first allele from a gene call string. Handles comma-separated multiple calls and allele notation.\n\nExamples\n\nfirst_allele(\"IGHV1-2*01,IGHV1-2*02\") # \"IGHV1-2*01\"\nfirst_allele(\"IGHV1-2*01\")             # \"IGHV1-2*01\"\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.Repertoire","page":"API Reference","title":"RepertoireMetrics.Repertoire","text":"Repertoire{T<:Real}\n\nImmutable representation of a B cell repertoire for diversity analysis. Stores lineage counts in a type-stable manner for efficient metric computation.\n\nType parameter\n\nT: Numeric type for counts (typically Int or Float64)\n\nFields\n\ncounts::Vector{T}: Sorted vector of lineage counts (descending order)\nlineage_ids::Vector{String}: Lineage identifiers corresponding to counts\ndonor_id::String: Identifier for the donor/sample\ntotal_count::T: Total count (cached for efficiency)\nmetadata::Dict{String,Any}: Optional metadata (flexible storage for extensibility;  known keys like \"length_stats\" contain typed values)\n\nConstruction\n\nUse the constructors or read_repertoire for type-safe creation.\n\nExample\n\n# From counts directly\nrep = Repertoire([100, 50, 25, 10, 5], donor_id=\"Donor1\")\n\n# From DataFrame\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition())\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.RepertoireCollection","page":"API Reference","title":"RepertoireMetrics.RepertoireCollection","text":"RepertoireCollection{T<:Real}\n\nCollection of repertoires from multiple donors for comparative analysis.\n\nFields\n\nrepertoires::Vector{Repertoire{T}}: Vector of repertoires\ndonor_ids::Vector{String}: Donor identifiers (for quick lookup)\n\nExample\n\ncollection = RepertoireCollection([rep1, rep2, rep3])\nmetrics = compute_metrics(collection)  # Returns vector of DiversityMetrics\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.richness","page":"API Reference","title":"RepertoireMetrics.richness","text":"richness(rep::Repertoire) -> Int\n\nReturn the number of unique lineages (richness/species count).\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.total_count","page":"API Reference","title":"RepertoireMetrics.total_count","text":"total_count(rep::Repertoire) -> T\n\nReturn the total count across all lineages.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.frequencies","page":"API Reference","title":"RepertoireMetrics.frequencies","text":"frequencies(rep::Repertoire{T}) -> Vector{Float64}\n\nReturn normalized frequencies (proportions) for each lineage. Frequencies sum to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.counts","page":"API Reference","title":"RepertoireMetrics.counts","text":"counts(rep::Repertoire) -> Vector{T}\n\nReturn the count vector (sorted descending).\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.lineage_ids","page":"API Reference","title":"RepertoireMetrics.lineage_ids","text":"lineage_ids(rep::Repertoire) -> Vector{String}\n\nReturn lineage identifiers (sorted by count descending).\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.donor_id","page":"API Reference","title":"RepertoireMetrics.donor_id","text":"donor_id(rep::Repertoire) -> String\n\nReturn the donor/sample identifier.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.read_repertoire","page":"API Reference","title":"RepertoireMetrics.read_repertoire","text":"read_repertoire(\n    filepath::AbstractString,\n    strategy::AbstractLineageDefinition;\n    count_column::Union{Symbol,Nothing} = :count,\n    donor_id::String = \"\",\n    donor_column::Union{Symbol,Nothing} = nothing,\n    length_column::Union{Symbol,Nothing} = nothing,\n    length_aa::Bool = false,\n    kwargs...\n) -> Repertoire{Int}\n\nRead a MIAIRR TSV file and convert to a Repertoire.\n\nArguments\n\nfilepath: Path to TSV file\nstrategy: Lineage definition strategy\ncount_column: Column containing sequence counts (default :count)\ndonor_id: Donor/sample identifier\ndonor_column: Column to extract donor ID from (e.g., :library_id)\nlength_column: Column to compute length statistics from (e.g., :cdr3)\nlength_aa: If true, length_column contains amino acid sequences\nkwargs...: Additional arguments passed to CSV.read\n\nExample\n\n# Using lineage_id column\nrep = read_repertoire(\"collapsed_data.tsv\", LineageIDDefinition())\n\n# Using V-J-CDR3 definition with CDR3 length stats\nrep = read_repertoire(\"sequences.tsv\", VJCdr3Definition(); length_column=:cdr3)\n\n# With donor ID from file\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition(); donor_column=:library_id)\n\n# Compute length from amino acid column\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition(); \n    length_column=:cdr3_aa, length_aa=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.read_repertoires","page":"API Reference","title":"RepertoireMetrics.read_repertoires","text":"read_repertoires(\n    filepaths::Vector{<:AbstractString},\n    strategy::AbstractLineageDefinition;\n    kwargs...\n) -> RepertoireCollection{Int}\n\nRead multiple MIAIRR TSV files and return a collection.\n\nExample\n\nfiles = [\"donor1.tsv\", \"donor2.tsv\", \"donor3.tsv\"]\ncollection = read_repertoires(files, VJCdr3Definition())\nall_metrics = compute_metrics(collection)\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.read_repertoires_from_directory","page":"API Reference","title":"RepertoireMetrics.read_repertoires_from_directory","text":"read_repertoires_from_directory(\n    dirpath::AbstractString,\n    strategy::AbstractLineageDefinition;\n    pattern::Regex = r\"\\.tsv$\"i,\n    kwargs...\n) -> RepertoireCollection{Int}\n\nRead all matching files from a directory and return a collection.\n\nArguments\n\ndirpath: Path to directory containing TSV files\nstrategy: Lineage definition strategy\npattern: Regex pattern to match filenames (default: .tsv files)\nkwargs...: Additional arguments passed to read_repertoire\n\nExample\n\ncollection = read_repertoires_from_directory(\"data/\", VJCdr3Definition())\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.repertoire_from_dataframe","page":"API Reference","title":"RepertoireMetrics.repertoire_from_dataframe","text":"repertoire_from_dataframe(\n    df::DataFrame,\n    strategy::AbstractLineageDefinition;\n    count_column::Union{Symbol,Nothing} = :count,\n    donor_id::String = \"\",\n    donor_column::Union{Symbol,Nothing} = nothing,\n    length_column::Union{Symbol,Nothing} = nothing,\n    length_aa::Bool = false\n) -> Repertoire{Int}\n\nConvert a DataFrame to a Repertoire using the specified lineage definition strategy.\n\nArguments\n\ndf: Input DataFrame in MIAIRR format\nstrategy: Lineage definition strategy (e.g., VJCdr3Definition(), LineageIDDefinition())\ncount_column: Column containing sequence counts (default :count). If nothing or  column doesn't exist, each row counts as 1.\ndonor_id: Donor/sample identifier. If empty and donor_column is specified,  extracts from first row.\ndonor_column: Column containing donor IDs (e.g., :library_id)\nlength_column: Column to compute length statistics from (e.g., :cdr3, :junction). If nothing (default), no length statistics are computed.\nlength_aa: If true, length_column contains amino acid sequences. If false (default), assumes nucleotide sequences and converts to amino acid length (÷3).\n\nReturns\n\nA Repertoire{Int} with aggregated lineage counts. If length_column is specified, length statistics are stored in metadata and accessible via composable metrics like MeanLength(), MedianLength(), etc.\n\nExample\n\ndf = CSV.read(\"sequences.tsv\", DataFrame)\n\n# Basic repertoire\nrep = repertoire_from_dataframe(df, VJCdr3Definition())\n\n# With CDR3 length statistics\nrep = repertoire_from_dataframe(df, VJCdr3Definition(); length_column=:cdr3)\nprintln(mean_length(rep))  # Access via function\nmetrics = compute_metrics(rep, MeanLength() + MedianLength())  # Or compose\n\n# Using amino acid column directly\nrep = repertoire_from_dataframe(df, VJCdr3Definition(); \n    length_column=:cdr3_aa, length_aa=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.split_by_donor","page":"API Reference","title":"RepertoireMetrics.split_by_donor","text":"split_by_donor(\n    df::DataFrame,\n    donor_column::Symbol,\n    strategy::AbstractLineageDefinition;\n    kwargs...\n) -> RepertoireCollection{Int}\n\nSplit a multi-donor DataFrame into separate Repertoires by donor.\n\nArguments\n\ndf: DataFrame containing data from multiple donors\ndonor_column: Column containing donor identifiers\nstrategy: Lineage definition strategy\nkwargs...: Additional arguments passed to repertoire_from_dataframe\n\nExample\n\ndf = CSV.read(\"all_donors.tsv\", DataFrame)\ncollection = split_by_donor(df, :library_id, VJCdr3Definition())\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.compute_metrics","page":"API Reference","title":"RepertoireMetrics.compute_metrics","text":"compute_metrics(rep::Repertoire) -> Metrics\ncompute_metrics(rep::Repertoire, metrics::MetricSet) -> Metrics\n\nCompute metrics for a repertoire. Without a MetricSet argument, computes all metrics.\n\nExamples\n\n# Compute all metrics (default)\nresult = compute_metrics(rep)\n\n# Compute specific metrics\nresult = compute_metrics(rep, ShannonEntropy() + Clonality() + D50())\n\n# Use predefined sets\nresult = compute_metrics(rep, DIVERSITY_METRICS)\n\n\n\n\n\ncompute_metrics(collection::RepertoireCollection) -> Vector{Metrics}\ncompute_metrics(collection::RepertoireCollection, metrics::MetricSet) -> Vector{Metrics}\n\nCompute metrics for all repertoires in a collection.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.Metrics","page":"API Reference","title":"RepertoireMetrics.Metrics","text":"Metrics <: AbstractMetricResult\n\nResult container for computed metrics. Access values by property name. All values are stored as Float64 for type stability.\n\nExample\n\nresult = compute_metrics(rep)\nprintln(result.shannon_entropy)\nprintln(result.clonality)\nprintln(result.d50)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.compute_metric","page":"API Reference","title":"RepertoireMetrics.compute_metric","text":"compute_metric(rep::Repertoire, metric::AbstractMetric) -> value\n\nCompute a single metric for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.shannon_entropy","page":"API Reference","title":"RepertoireMetrics.shannon_entropy","text":"shannon_entropy(freqs::Vector{Float64}) -> Float64\n\nCompute Shannon entropy H = -Σ(pᵢ log pᵢ) using natural logarithm. Zero frequencies are handled correctly (0 * log(0) = 0).\n\n\n\n\n\nshannon_entropy(rep::Repertoire) -> Float64\n\nCompute Shannon entropy for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.simpson_index","page":"API Reference","title":"RepertoireMetrics.simpson_index","text":"simpson_index(freqs::Vector{Float64}) -> Float64\n\nCompute Simpson's index D = Σpᵢ². This is the probability that two randomly selected individuals belong to the same lineage.\n\n\n\n\n\nsimpson_index(rep::Repertoire) -> Float64\n\nCompute Simpson's index for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.simpson_diversity","page":"API Reference","title":"RepertoireMetrics.simpson_diversity","text":"simpson_diversity(rep::Repertoire) -> Float64\n\nCompute Simpson's diversity (1 - D) for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.inverse_simpson","page":"API Reference","title":"RepertoireMetrics.inverse_simpson","text":"inverse_simpson(rep::Repertoire) -> Float64\n\nCompute inverse Simpson index (1/D) for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.berger_parker_index","page":"API Reference","title":"RepertoireMetrics.berger_parker_index","text":"berger_parker_index(freqs::Vector{Float64}) -> Float64\n\nCompute Berger-Parker index: proportion of the most abundant lineage. Assumes frequencies are sorted in descending order.\n\n\n\n\n\nberger_parker_index(rep::Repertoire) -> Float64\n\nCompute Berger-Parker index for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.gini_coefficient","page":"API Reference","title":"RepertoireMetrics.gini_coefficient","text":"gini_coefficient(freqs::Vector{Float64}) -> Float64\n\nCompute Gini coefficient measuring inequality in lineage abundances. Returns 0 for perfect equality, approaches 1 for maximum inequality.\n\n\n\n\n\ngini_coefficient(rep::Repertoire) -> Float64\n\nCompute Gini coefficient for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.clonality","page":"API Reference","title":"RepertoireMetrics.clonality","text":"clonality(rep::Repertoire) -> Float64\n\nCompute clonality: 1 - normalized Shannon entropy. High clonality indicates oligoclonal expansion. Range: [0, 1] where 1 = maximally clonal (single dominant lineage).\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.evenness","page":"API Reference","title":"RepertoireMetrics.evenness","text":"evenness(rep::Repertoire) -> Float64\n\nCompute Pielou's evenness J = H / H_max. Range: [0, 1] where 1 = perfectly even distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.d50","page":"API Reference","title":"RepertoireMetrics.d50","text":"d50(counts::Vector{<:Real}) -> Int\n\nCompute D50: minimum number of lineages comprising 50% of total repertoire. Assumes counts are sorted in descending order.\n\n\n\n\n\nd50(rep::Repertoire) -> Int\n\nCompute D50 for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.chao1","page":"API Reference","title":"RepertoireMetrics.chao1","text":"chao1(counts::Vector{<:Integer}) -> Float64\n\nCompute Chao1 richness estimator. Estimates total species richness including unobserved species.\n\nFormula: Schao1 = Sobs + f₁²/(2f₂) where f₁ = singletons, f₂ = doubletons\n\nIf f₂ = 0, uses bias-corrected formula: S_obs + f₁(f₁-1)/2\n\n\n\n\n\nchao1(rep::Repertoire) -> Float64\n\nCompute Chao1 richness estimator for a repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.hill_number","page":"API Reference","title":"RepertoireMetrics.hill_number","text":"hill_number(freqs::Vector{Float64}, q::Real) -> Float64\n\nCompute Hill number of order q. Hill numbers provide a unified framework for diversity metrics.\n\nSpecial cases\n\nq=0: Richness (number of species with non-zero frequency)\nq=1: exp(Shannon entropy) - uses L'Hôpital's rule limit\nq=2: Inverse Simpson (1/Σpᵢ²)\nq→∞: 1/max(pᵢ) (reciprocal of Berger-Parker)\n\nFormula\n\nᵍD = (Σpᵢᵍ)^(1/(1-q)) for q ≠ 1\n\n\n\n\n\nhill_number(rep::Repertoire, q::Real) -> HillNumber{Q}\n\nCompute Hill number of order q for a repertoire. Returns a typed HillNumber{Q} for compile-time known orders.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.HillNumber","page":"API Reference","title":"RepertoireMetrics.HillNumber","text":"HillNumber{Q} <: AbstractMetricResult\n\nHill number of order Q, providing a unified framework for diversity.\n\nType parameter\n\nQ: Order of the Hill number (compile-time constant for type stability)\n\nFields\n\nvalue::Float64: The computed Hill number\nrichness::Int: Number of unique lineages\ntotal_count::Int: Total count\n\nSpecial cases\n\nQ=0: Richness (number of species)\nQ=1: Exponential of Shannon entropy\nQ=2: Inverse Simpson index\nQ=∞: Reciprocal of Berger-Parker index\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.AbstractMetric","page":"API Reference","title":"RepertoireMetrics.AbstractMetric","text":"AbstractMetric\n\nAbstract supertype for individual metric selectors. Each concrete subtype represents a specific diversity/clonality metric.\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.MetricSet","page":"API Reference","title":"RepertoireMetrics.MetricSet","text":"MetricSet{M<:Tuple}\n\nA composable set of metrics to compute. Use the + operator to combine metrics.\n\nExamples\n\n# Select specific metrics\nmetrics = Richness() + ShannonEntropy() + Clonality()\nresult = compute_metrics(rep, metrics)\n\n# Use predefined sets\nresult = compute_metrics(rep, DIVERSITY_METRICS)\nresult = compute_metrics(rep, ALL_METRICS)\n\n# Default computes all metrics\nresult = compute_metrics(rep)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.ALL_METRICS","page":"API Reference","title":"RepertoireMetrics.ALL_METRICS","text":"ALL_METRICS\n\nAll available metrics. This is the default when calling compute_metrics(rep).\n\n\n\n\n\n","category":"constant"},{"location":"api/#RepertoireMetrics.DIVERSITY_METRICS","page":"API Reference","title":"RepertoireMetrics.DIVERSITY_METRICS","text":"DIVERSITY_METRICS\n\nCommon diversity metrics: Shannon entropy/diversity, Simpson diversity, inverse Simpson.\n\n\n\n\n\n","category":"constant"},{"location":"api/#RepertoireMetrics.CLONALITY_METRICS","page":"API Reference","title":"RepertoireMetrics.CLONALITY_METRICS","text":"CLONALITY_METRICS\n\nMetrics focused on clonal expansion: clonality, Gini, Berger-Parker, D50.\n\n\n\n\n\n","category":"constant"},{"location":"api/#RepertoireMetrics.RICHNESS_METRICS","page":"API Reference","title":"RepertoireMetrics.RICHNESS_METRICS","text":"RICHNESS_METRICS\n\nRichness-related metrics: observed richness and Chao1 estimator.\n\n\n\n\n\n","category":"constant"},{"location":"api/#RepertoireMetrics.Richness","page":"API Reference","title":"RepertoireMetrics.Richness","text":"Richness: Number of unique lineages (S)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.TotalCount","page":"API Reference","title":"RepertoireMetrics.TotalCount","text":"TotalCount: Total sequence/cell count (N)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.ShannonEntropy","page":"API Reference","title":"RepertoireMetrics.ShannonEntropy","text":"ShannonEntropy: H = -Σ(pᵢ log pᵢ)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.ShannonDiversity","page":"API Reference","title":"RepertoireMetrics.ShannonDiversity","text":"ShannonDiversity: exp(H) - effective number of lineages\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.NormalizedShannon","page":"API Reference","title":"RepertoireMetrics.NormalizedShannon","text":"NormalizedShannon: H / log(S), normalized to [0,1]\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.SimpsonIndex","page":"API Reference","title":"RepertoireMetrics.SimpsonIndex","text":"SimpsonIndex: D = Σpᵢ² - probability two random sequences are same lineage\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.SimpsonDiversity","page":"API Reference","title":"RepertoireMetrics.SimpsonDiversity","text":"SimpsonDiversity: 1 - D (Gini-Simpson index)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.InverseSimpson","page":"API Reference","title":"RepertoireMetrics.InverseSimpson","text":"InverseSimpson: 1/D - effective number of lineages (Hill q=2)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.BergerParker","page":"API Reference","title":"RepertoireMetrics.BergerParker","text":"BergerParker: Proportion of most abundant lineage\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.Evenness","page":"API Reference","title":"RepertoireMetrics.Evenness","text":"Evenness: Pielou's J = H / log(S)\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.Clonality","page":"API Reference","title":"RepertoireMetrics.Clonality","text":"Clonality: 1 - normalized Shannon entropy\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.GiniCoefficient","page":"API Reference","title":"RepertoireMetrics.GiniCoefficient","text":"GiniCoefficient: Inequality measure [0,1]\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.D50","page":"API Reference","title":"RepertoireMetrics.D50","text":"D50: Minimum lineages comprising 50% of repertoire\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.Chao1","page":"API Reference","title":"RepertoireMetrics.Chao1","text":"Chao1: Richness estimator including unobserved species\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.rarefaction","page":"API Reference","title":"RepertoireMetrics.rarefaction","text":"rarefaction(rep::Repertoire, depth::Integer; rng=nothing) -> Repertoire\n\nRandomly subsample a repertoire to a specified depth (total count).\n\nMany diversity metrics are sensitive to sample size—deeper sequencing captures more  rare lineages. Rarefaction normalizes sample sizes by randomly subsampling all  repertoires to the same depth, enabling fair comparisons.\n\nArguments\n\nrep: Input repertoire\ndepth: Target total count (must be ≤ current total count of rep)\nrng: Optional random number generator for reproducibility\n\nReturns\n\nA new Repertoire with subsampled counts. Lineages that received zero counts  in the subsample are removed.\n\nExample\n\n# Compare two repertoires of different sizes\nrep1 = read_repertoire(\"donor1.tsv\", VJCdr3Definition())  # 50,000 sequences\nrep2 = read_repertoire(\"donor2.tsv\", VJCdr3Definition())  # 12,000 sequences\n\n# Rarefy to the smaller depth\ntarget = min(total_count(rep1), total_count(rep2))\nrep1_rare = rarefaction(rep1, target)\nrep2_rare = rarefaction(rep2, target)\n\n# Now compare fairly\ncompute_metrics(rep1_rare)\ncompute_metrics(rep2_rare)\n\n# For reproducibility, use a fixed RNG\nusing Random\nrng = MersenneTwister(42)\nrarefied = rarefaction(rep, 10000; rng=rng)\n\nNotes\n\nRarefaction is stochastic; results vary between runs unless rng is fixed\nFor robust estimates, consider averaging metrics over multiple rarefactions\nMetrics like Simpson index are naturally less sensitive to sample size\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.metrics_to_dataframe","page":"API Reference","title":"RepertoireMetrics.metrics_to_dataframe","text":"metrics_to_dataframe(m::Metrics, donor_id::String=\"\") -> DataFrame\n\nConvert Metrics to a single-row DataFrame.\n\n\n\n\n\nmetrics_to_dataframe(collection::RepertoireCollection, metrics::Vector{Metrics}) -> DataFrame\n\nConvert a collection's metrics to a DataFrame with one row per donor.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.write_metrics","page":"API Reference","title":"RepertoireMetrics.write_metrics","text":"write_metrics(filepath::AbstractString, df::DataFrame; kwargs...)\n\nWrite metrics DataFrame to a TSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.LengthStats","page":"API Reference","title":"RepertoireMetrics.LengthStats","text":"LengthStats\n\nContainer for sequence length statistics, stored in Repertoire metadata.\n\nFields\n\nmean_length::Float64: Mean sequence length\nmedian_length::Float64: Median sequence length  \nstd_length::Float64: Standard deviation of sequence length\nmin_length::Int: Minimum sequence length\nmax_length::Int: Maximum sequence length\nn_sequences::Int: Number of sequences analyzed\ncolumn::Symbol: Column used for length calculation\nuse_aa::Bool: Whether lengths are in amino acids\n\nComputed during repertoire construction when a length_column is specified.\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.compute_length_stats","page":"API Reference","title":"RepertoireMetrics.compute_length_stats","text":"compute_length_stats(df::DataFrame; length_column=:cdr3, count_column=nothing, use_aa=false) -> LengthStats\n\nCompute length statistics from a DataFrame column.\n\nArguments\n\ndf: DataFrame containing sequences\nlength_column: Column to measure length from (default :cdr3)\ncount_column: If provided, weight statistics by this count column\nuse_aa: If true, column contains amino acid sequences. If false (default), assumes nucleotide sequences and divides length by 3.\n\nReturns\n\nA LengthStats object with computed statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.length_distribution","page":"API Reference","title":"RepertoireMetrics.length_distribution","text":"length_distribution(df::DataFrame; length_column=:cdr3, count_column=nothing, use_aa=false) -> Dict{Int,Int}\n\nCompute the distribution of sequence lengths.\n\nArguments\n\ndf: DataFrame containing sequences\nlength_column: Column to measure length from (default :cdr3)\ncount_column: If provided, weight by this count column\nuse_aa: If true, column contains amino acid sequences\n\nReturns\n\nA Dict{Int,Int} mapping length to count.\n\nExample\n\ndist = length_distribution(df; length_column=:cdr3)\nfor (len, cnt) in sort(collect(dist))\n    println(\"Length $len: $cnt sequences\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.has_length_stats","page":"API Reference","title":"RepertoireMetrics.has_length_stats","text":"has_length_stats(rep::Repertoire) -> Bool\n\nCheck if length statistics are available for this repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.length_stats","page":"API Reference","title":"RepertoireMetrics.length_stats","text":"length_stats(rep::Repertoire) -> LengthStats\n\nReturn the LengthStats object for this repertoire.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.MeanLength","page":"API Reference","title":"RepertoireMetrics.MeanLength","text":"MeanLength <: AbstractMetric\n\nMetric type for mean sequence length. Requires length_column to be specified during repertoire construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.MedianLength","page":"API Reference","title":"RepertoireMetrics.MedianLength","text":"MedianLength <: AbstractMetric\n\nMetric type for median sequence length.\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.StdLength","page":"API Reference","title":"RepertoireMetrics.StdLength","text":"StdLength <: AbstractMetric\n\nMetric type for standard deviation of sequence length.\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.MinLength","page":"API Reference","title":"RepertoireMetrics.MinLength","text":"MinLength <: AbstractMetric\n\nMetric type for minimum sequence length.\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.MaxLength","page":"API Reference","title":"RepertoireMetrics.MaxLength","text":"MaxLength <: AbstractMetric\n\nMetric type for maximum sequence length.\n\n\n\n\n\n","category":"type"},{"location":"api/#RepertoireMetrics.mean_length","page":"API Reference","title":"RepertoireMetrics.mean_length","text":"mean_length(rep::Repertoire) -> Float64\n\nReturn the mean sequence length. Requires length statistics to be computed during repertoire construction (via length_column parameter).\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.median_length","page":"API Reference","title":"RepertoireMetrics.median_length","text":"median_length(rep::Repertoire) -> Float64\n\nReturn the median sequence length.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.std_length","page":"API Reference","title":"RepertoireMetrics.std_length","text":"std_length(rep::Repertoire) -> Float64\n\nReturn the standard deviation of sequence length.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.min_length","page":"API Reference","title":"RepertoireMetrics.min_length","text":"min_length(rep::Repertoire) -> Int\n\nReturn the minimum sequence length.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.max_length","page":"API Reference","title":"RepertoireMetrics.max_length","text":"max_length(rep::Repertoire) -> Int\n\nReturn the maximum sequence length.\n\n\n\n\n\n","category":"function"},{"location":"api/#RepertoireMetrics.LENGTH_METRICS","page":"API Reference","title":"RepertoireMetrics.LENGTH_METRICS","text":"LENGTH_METRICS\n\nPredefined MetricSet containing all length metrics: MeanLength() + MedianLength() + StdLength() + MinLength() + MaxLength()\n\n\n\n\n\n","category":"constant"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"This guide covers the essential workflows for analyzing B cell repertoire diversity.","category":"section"},{"location":"quickstart/#Reading-Repertoire-Data","page":"Quick Start","title":"Reading Repertoire Data","text":"RepertoireMetrics.jl reads MIAIRR-formatted TSV files. You need to specify how lineages are defined.","category":"section"},{"location":"quickstart/#Using-lineage_id-Column","page":"Quick Start","title":"Using lineage_id Column","text":"If your data has been pre-processed with lineage assignment (e.g., by LineageCollapse.jl):\n\nusing RepertoireMetrics\n\nrep = read_repertoire(\"collapsed_data.tsv\", LineageIDDefinition())","category":"section"},{"location":"quickstart/#Using-V-J-CDR3-Combination","page":"Quick Start","title":"Using V-J-CDR3 Combination","text":"Define lineages by V gene, J gene, and CDR3 sequence (compatible with LineageCollapse.jl's default behavior):\n\nrep = read_repertoire(\"sequences.tsv\", VJCdr3Definition())\n\nThe VJCdr3Definition automatically uses the first allele from gene calls. You can customize this:\n\n# Use full gene call (with all alleles)\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition(use_first_allele=false))\n\n# Use different column names\nstrategy = VJCdr3Definition(\n    v_column = :v_gene,\n    j_column = :j_gene,\n    cdr3_column = :cdr3_aa\n)","category":"section"},{"location":"quickstart/#Handling-Counts","page":"Quick Start","title":"Handling Counts","text":"By default, the package looks for a count column. If not present, each row is counted as 1:\n\n# Explicit: use count column\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition(); count_column=:count)\n\n# Each row = 1 sequence\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition(); count_column=nothing)","category":"section"},{"location":"quickstart/#Computing-Metrics","page":"Quick Start","title":"Computing Metrics","text":"","category":"section"},{"location":"quickstart/#All-Metrics-(Default)","page":"Quick Start","title":"All Metrics (Default)","text":"metrics = compute_metrics(rep)\nprintln(metrics)\n\nOutput:\n\nMetrics (14 computed):\n  richness: 1523\n  total_count: 50000\n  shannon_entropy: 5.2341\n  ...\n  clonality: 0.2854\n  ...","category":"section"},{"location":"quickstart/#Accessing-Individual-Values","page":"Quick Start","title":"Accessing Individual Values","text":"println(\"Clonality: \", metrics.clonality)\nprintln(\"Shannon entropy: \", metrics.shannon_entropy)\nprintln(\"D50: \", metrics.d50)","category":"section"},{"location":"quickstart/#Computing-Specific-Metrics","page":"Quick Start","title":"Computing Specific Metrics","text":"Select specific metrics using the + operator:\n\n# Define which metrics to compute\nselected = ShannonEntropy() + Clonality() + D50() + Chao1()\n\n# Compute only those\nresult = compute_metrics(rep, selected)\nprintln(result.shannon_entropy)\nprintln(result.clonality)\n\nUse predefined sets:\n\n# Diversity-focused metrics\nresult = compute_metrics(rep, DIVERSITY_METRICS)\n\n# Clonality-focused metrics  \nresult = compute_metrics(rep, CLONALITY_METRICS)","category":"section"},{"location":"quickstart/#Direct-Metric-Functions","page":"Quick Start","title":"Direct Metric Functions","text":"For single metrics, you can also call functions directly:\n\nH = shannon_entropy(rep)\nC = clonality(rep)\nd = d50(rep)","category":"section"},{"location":"quickstart/#Multi-Donor-Analysis","page":"Quick Start","title":"Multi-Donor Analysis","text":"","category":"section"},{"location":"quickstart/#Reading-Multiple-Files","page":"Quick Start","title":"Reading Multiple Files","text":"# From a list of files\nfiles = [\"donor1.tsv\", \"donor2.tsv\", \"donor3.tsv\"]\ncollection = read_repertoires(files, VJCdr3Definition())\n\n# From a directory\ncollection = read_repertoires_from_directory(\"data/\", VJCdr3Definition())","category":"section"},{"location":"quickstart/#Splitting-a-Multi-Donor-File","page":"Quick Start","title":"Splitting a Multi-Donor File","text":"using CSV, DataFrames\n\ndf = CSV.read(\"all_donors.tsv\", DataFrame)\ncollection = split_by_donor(df, :library_id, VJCdr3Definition())","category":"section"},{"location":"quickstart/#Computing-Metrics-for-All-Donors","page":"Quick Start","title":"Computing Metrics for All Donors","text":"# Compute all metrics\nall_metrics = compute_metrics(collection)\n\n# Or selected metrics\nall_metrics = compute_metrics(collection, CLONALITY_METRICS)","category":"section"},{"location":"quickstart/#Exporting-Results","page":"Quick Start","title":"Exporting Results","text":"# Convert to DataFrame\ndf_results = metrics_to_dataframe(collection, all_metrics)\n\n# Write to TSV\nwrite_metrics(\"results.tsv\", df_results)","category":"section"},{"location":"quickstart/#Custom-Lineage-Definition","page":"Quick Start","title":"Custom Lineage Definition","text":"For advanced use cases, define your own grouping:\n\n# Group by V gene family only\nstrategy = CustomDefinition(row -> begin\n    v = string(row.v_call)\n    # Extract family (e.g., \"IGHV1\" from \"IGHV1-2*01\")\n    m = match(r\"^(IGH?V\\d+)\", v)\n    return m === nothing ? v : m.captures[1]\nend)\n\nrep = read_repertoire(\"data.tsv\", strategy)","category":"section"},{"location":"quickstart/#Hill-Numbers","page":"Quick Start","title":"Hill Numbers","text":"For a unified view of diversity across different orders:\n\n# q=0: Richness\nh0 = hill_number(rep, 0)\n\n# q=1: exp(Shannon entropy)\nh1 = hill_number(rep, 1)\n\n# q=2: Inverse Simpson\nh2 = hill_number(rep, 2)\n\n# Arbitrary order\nh_half = hill_number(rep, 0.5)","category":"section"},{"location":"quickstart/#Rarefaction-for-Comparing-Uneven-Samples","page":"Quick Start","title":"Rarefaction for Comparing Uneven Samples","text":"","category":"section"},{"location":"quickstart/#The-Problem-with-Uneven-Sample-Sizes","page":"Quick Start","title":"The Problem with Uneven Sample Sizes","text":"Many diversity metrics are sensitive to sample size (sequencing depth). A repertoire with 100,000 sequences will almost always appear more diverse than one with 10,000 sequences, even if the underlying distributions are identical. This is because deeper sequencing captures more rare lineages.\n\nMetrics most affected by sample size:\n\nRichness - heavily affected (more sampling = more lineages detected)\nChao1 - heavily affected (relies on singletons/doubletons)\nShannon entropy - moderately affected\nSimpson index - less affected (dominated by abundant lineages)","category":"section"},{"location":"quickstart/#What-is-Rarefaction?","page":"Quick Start","title":"What is Rarefaction?","text":"Rarefaction is the process of randomly subsampling a repertoire to a fixed depth (total count). By subsampling all repertoires to the same depth, you can make fair comparisons.","category":"section"},{"location":"quickstart/#Basic-Usage","page":"Quick Start","title":"Basic Usage","text":"# Check sample sizes\nprintln(\"Rep1: \", total_count(rep1))  # e.g., 50,000\nprintln(\"Rep2: \", total_count(rep2))  # e.g., 12,000\n\n# Rarefy both to the smaller size\ntarget_depth = min(total_count(rep1), total_count(rep2))\nrep1_rarefied = rarefaction(rep1, target_depth)\nrep2_rarefied = rarefaction(rep2, target_depth)\n\n# Now compare fairly\nmetrics1 = compute_metrics(rep1_rarefied)\nmetrics2 = compute_metrics(rep2_rarefied)","category":"section"},{"location":"quickstart/#Reproducibility-with-Random-Seed","page":"Quick Start","title":"Reproducibility with Random Seed","text":"Rarefaction involves random sampling. For reproducible results, provide a random number generator:\n\nusing Random\n\nrng = MersenneTwister(42)  # Fixed seed\nrarefied = rarefaction(rep, 10000; rng=rng)","category":"section"},{"location":"quickstart/#Rarefaction-Curves","page":"Quick Start","title":"Rarefaction Curves","text":"To understand how metrics change with sequencing depth, compute metrics at multiple depths:\n\ndepths = [1000, 5000, 10000, 25000, 50000]\nresults = []\n\nfor d in depths\n    if d <= total_count(rep)\n        rarefied = rarefaction(rep, d)\n        m = compute_metrics(rarefied, Richness() + ShannonEntropy())\n        push!(results, (depth=d, richness=m.richness, shannon=m.shannon_entropy))\n    end\nend","category":"section"},{"location":"quickstart/#Best-Practices","page":"Quick Start","title":"Best Practices","text":"Choose a common depth - Use the minimum depth across all samples you want to compare\nDon't rarefy too aggressively - Very low depths lose too much information\nConsider multiple rarefactions - Average results over several random subsamples for robustness\nReport the depth used - Always document the rarefaction depth in your analysis\nAlternative: use robust metrics - Simpson index and Berger-Parker are naturally less sensitive to sample size","category":"section"},{"location":"quickstart/#When-NOT-to-Use-Rarefaction","page":"Quick Start","title":"When NOT to Use Rarefaction","text":"When comparing samples of similar depth (within ~2-fold)\nWhen using metrics insensitive to depth (Simpson, Berger-Parker)\nWhen absolute richness (not relative comparison) is the goal","category":"section"},{"location":"quickstart/#Length-Metrics-(CDR3-and-more)","page":"Quick Start","title":"Length Metrics (CDR3 and more)","text":"Sequence length is an important repertoire characteristic. CDR3 length in particular is associated with binding specificity. RepertoireMetrics provides composable length metrics that integrate seamlessly with diversity metrics.","category":"section"},{"location":"quickstart/#Enabling-Length-Statistics","page":"Quick Start","title":"Enabling Length Statistics","text":"Specify a length_column when creating your repertoire:\n\nusing RepertoireMetrics\n\n# Read repertoire with CDR3 length statistics\nrep = read_repertoire(\"sequences.tsv\", VJCdr3Definition(); \n    length_column=:cdr3)  # Default: nucleotide → amino acid conversion\n\n# Or from DataFrame\ndf = CSV.read(\"sequences.tsv\", DataFrame)\nrep = repertoire_from_dataframe(df, VJCdr3Definition();\n    count_column=:count,\n    length_column=:cdr3)","category":"section"},{"location":"quickstart/#Accessing-Length-Statistics","page":"Quick Start","title":"Accessing Length Statistics","text":"# Direct accessors\nprintln(\"Mean CDR3 length: \", mean_length(rep))\nprintln(\"Median: \", median_length(rep))\nprintln(\"Std: \", std_length(rep))\nprintln(\"Range: \", min_length(rep), \" - \", max_length(rep))\n\n# Get full stats object\nstats = length_stats(rep)\nprintln(stats)","category":"section"},{"location":"quickstart/#Composable-Length-Metrics","page":"Quick Start","title":"Composable Length Metrics","text":"Length metrics work with the same + operator as diversity metrics:\n\n# Just length metrics\nmetrics = compute_metrics(rep, MeanLength() + MedianLength())\n\n# Mix with diversity metrics\nmetrics = compute_metrics(rep, \n    Richness() + ShannonEntropy() + MeanLength() + StdLength())\n\n# All length metrics at once\nmetrics = compute_metrics(rep, LENGTH_METRICS)","category":"section"},{"location":"quickstart/#Flexible-Column-Selection","page":"Quick Start","title":"Flexible Column Selection","text":"The length_column parameter accepts any column name, making it useful for:\n\nCDR3 nucleotide (:cdr3) - converted to AA length\nCDR3 amino acid (:cdr3_aa) - use with length_aa=true\nJunction (:junction)\nAny other sequence column\n\n# Using amino acid column directly\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition();\n    length_column=:cdr3_aa,\n    length_aa=true)\n\n# Using junction length\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition();\n    length_column=:junction)","category":"section"},{"location":"quickstart/#Length-Distribution","page":"Quick Start","title":"Length Distribution","text":"For detailed analysis, get the full distribution:\n\ndist = length_distribution(df; length_column=:cdr3, count_column=:count)\n\nfor (len, cnt) in sort(collect(dist))\n    println(\"Length $len: $cnt sequences\")\nend","category":"section"},{"location":"quickstart/#Multi-Donor-Analysis-with-Length","page":"Quick Start","title":"Multi-Donor Analysis with Length","text":"# Read collection with length stats\nfiles = [\"donor1.tsv\", \"donor2.tsv\"]\ncollection = read_repertoires(files, VJCdr3Definition();\n    length_column=:cdr3)\n\n# Compute diversity + length metrics for all donors\nresults = compute_metrics(collection, \n    Richness() + ShannonEntropy() + MeanLength())\n\n# Convert to DataFrame for analysis\ndf = metrics_to_dataframe(collection, results)","category":"section"},{"location":"composable/#Composable-Metrics","page":"Composable Metrics","title":"Composable Metrics","text":"RepertoireMetrics.jl provides a flexible system for selecting which metrics to compute. This is useful when you:\n\nOnly need a few specific metrics\nWant to optimize performance by avoiding unnecessary computations\nAre building analysis pipelines with specific requirements","category":"section"},{"location":"composable/#Basic-Usage","page":"Composable Metrics","title":"Basic Usage","text":"","category":"section"},{"location":"composable/#The-Operator","page":"Composable Metrics","title":"The + Operator","text":"Combine metrics using the + operator:\n\nusing RepertoireMetrics\n\nrep = Repertoire([100, 50, 25, 10, 5])\n\n# Select specific metrics\nmetrics = ShannonEntropy() + Clonality() + D50()\nresult = compute_metrics(rep, metrics)\n\nprintln(result)\n# Output:\n# Metrics (3 computed):\n#   shannon_entropy: 1.2891\n#   clonality: 0.1991\n#   d50: 2","category":"section"},{"location":"composable/#Default:-All-Metrics","page":"Composable Metrics","title":"Default: All Metrics","text":"Without a second argument, compute_metrics computes all available metrics:\n\nresult = compute_metrics(rep)  # Same as compute_metrics(rep, ALL_METRICS)","category":"section"},{"location":"composable/#Available-Metric-Types","page":"Composable Metrics","title":"Available Metric Types","text":"Each metric has a corresponding type:\n\nType Computed Metric\nRichness() Number of unique lineages\nTotalCount() Total sequence count\nShannonEntropy() Shannon entropy H\nShannonDiversity() exp(H)\nNormalizedShannon() H / log(S)\nSimpsonIndex() Σpᵢ²\nSimpsonDiversity() 1 - Σpᵢ²\nInverseSimpson() 1 / Σpᵢ²\nBergerParker() max(pᵢ)\nEvenness() Pielou's J\nClonality() 1 - normalized Shannon\nGiniCoefficient() Gini index\nD50() D50\nChao1() Chao1 estimator\nMeanLength() Mean sequence length*\nMedianLength() Median sequence length*\nStdLength() Std dev of sequence length*\nMinLength() Minimum sequence length*\nMaxLength() Maximum sequence length*\n\n* Length metrics require length_column to be specified when creating the repertoire.","category":"section"},{"location":"composable/#Accessing-Results","page":"Composable Metrics","title":"Accessing Results","text":"The result is a Metrics object with property access:\n\nresult = compute_metrics(rep, ShannonEntropy() + Clonality())\n\n# Access by property name\nprintln(result.shannon_entropy)\nprintln(result.clonality)\n\n# Missing metrics return `missing`\nprintln(result.d50)  # missing (wasn't computed)","category":"section"},{"location":"composable/#Predefined-MetricSets","page":"Composable Metrics","title":"Predefined MetricSets","text":"For convenience, several predefined metric sets are available:","category":"section"},{"location":"composable/#ALL_METRICS-(default)","page":"Composable Metrics","title":"ALL_METRICS (default)","text":"All available metrics:\n\nresult = compute_metrics(rep)  # Uses ALL_METRICS by default","category":"section"},{"location":"composable/#DIVERSITY_METRICS","page":"Composable Metrics","title":"DIVERSITY_METRICS","text":"Metrics focused on repertoire diversity:\n\nresult = compute_metrics(rep, DIVERSITY_METRICS)\n# Includes: richness, total_count, shannon_entropy, shannon_diversity,\n#           simpson_diversity, inverse_simpson, evenness","category":"section"},{"location":"composable/#CLONALITY_METRICS","page":"Composable Metrics","title":"CLONALITY_METRICS","text":"Metrics focused on clonal expansion:\n\nresult = compute_metrics(rep, CLONALITY_METRICS)\n# Includes: richness, total_count, clonality, gini_coefficient,\n#           berger_parker, d50","category":"section"},{"location":"composable/#RICHNESS_METRICS","page":"Composable Metrics","title":"RICHNESS_METRICS","text":"Richness and its estimator:\n\nresult = compute_metrics(rep, RICHNESS_METRICS)\n# Includes: richness, total_count, chao1","category":"section"},{"location":"composable/#LENGTH_METRICS","page":"Composable Metrics","title":"LENGTH_METRICS","text":"All sequence length statistics (requires length_column during repertoire creation):\n\nrep = read_repertoire(\"data.tsv\", VJCdr3Definition(); length_column=:cdr3)\nresult = compute_metrics(rep, LENGTH_METRICS)\n# Includes: mean_length, median_length, std_length, min_length, max_length","category":"section"},{"location":"composable/#Combining-Sets-and-Metrics","page":"Composable Metrics","title":"Combining Sets and Metrics","text":"You can combine predefined sets with additional metrics:\n\n# Add Chao1 to diversity metrics\nextended = DIVERSITY_METRICS + Chao1()\nresult = compute_metrics(rep, extended)","category":"section"},{"location":"composable/#Multi-Donor-Analysis","page":"Composable Metrics","title":"Multi-Donor Analysis","text":"The composable system works with repertoire collections:\n\ncollection = read_repertoires_from_directory(\"data/\", VJCdr3Definition())\n\n# Compute only clonality metrics for all donors\nall_results = compute_metrics(collection, CLONALITY_METRICS)\n\n# Convert to DataFrame\ndf = metrics_to_dataframe(collection, all_results)","category":"section"},{"location":"composable/#Performance-Considerations","page":"Composable Metrics","title":"Performance Considerations","text":"Computing only the metrics you need can improve performance, especially when:\n\nProcessing many repertoires\nRunning in a loop or pipeline\nOnly needing basic counts (richness, total)\n\n# Fast: computes only 2 metrics\nresult = compute_metrics(rep, Richness() + TotalCount())\n\n# Slower: computes all 14 metrics\nresult = compute_metrics(rep)","category":"section"},{"location":"composable/#Type-Stability","page":"Composable Metrics","title":"Type Stability","text":"The composable system is designed for type stability:\n\n# MetricSet is parameterized by the tuple of metric types\nmetrics = ShannonEntropy() + Clonality()\ntypeof(metrics)  # MetricSet{Tuple{ShannonEntropy, Clonality}}\n\n# compute_metric dispatches on metric type\ncompute_metric(rep, ShannonEntropy())  # Calls shannon_entropy(rep)\ncompute_metric(rep, Clonality())       # Calls clonality(rep)\n\nThis means the compiler can specialize code for your specific metric selection, potentially enabling optimizations.","category":"section"},{"location":"#RepertoireMetrics.jl","page":"Home","title":"RepertoireMetrics.jl","text":"A Julia package for computing diversity and clonality metrics for B cell repertoire sequencing data.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"RepertoireMetrics.jl provides a comprehensive toolkit for analyzing the clonal composition of adaptive immune repertoires. It reads MIAIRR-formatted TSV files and computes standard diversity and clonality metrics used in immunology research.","category":"section"},{"location":"#What-are-Diversity-and-Clonality?","page":"Home","title":"What are Diversity and Clonality?","text":"Diversity and clonality are two perspectives on the same underlying phenomenon: the distribution of lineages (clones) in a B cell repertoire.\n\nDiversity measures how varied a repertoire is. High diversity indicates many unique lineages with relatively even abundances (a polyclonal repertoire).\nClonality measures the opposite: how dominated a repertoire is by a few lineages. High clonality indicates oligoclonal or monoclonal expansion.\n\nMathematically, clonality is typically defined as:\n\ntextClonality = 1 - fracHlog(S)\n\nwhere H is Shannon entropy and S is richness. This means clonality and normalized diversity sum to 1.","category":"section"},{"location":"#When-to-Use-Which?","page":"Home","title":"When to Use Which?","text":"Both metrics describe the same distribution, so the choice is often a matter of interpretation:\n\nMetric Interpretation High value means\nDiversity Variability Polyclonal, healthy repertoire\nClonality Dominance Oligoclonal expansion, possible antigen-driven response\n\nIn practice, researchers often report both, or choose based on their biological question:\n\nStudying immune reconstitution? Focus on diversity.\nInvestigating antigen-specific responses? Focus on clonality.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Flexible lineage definition: Use lineage_id, V-J-CDR3 combinations, or custom strategies\nComprehensive metrics: Shannon, Simpson, Gini, Hill numbers, Chao1, D50, and more\nComposable metric selection: Choose which metrics to compute with the + operator\nSequence length statistics: CDR3 or any column, also composable\nType-stable design: Proper Julia abstractions for performance\nMulti-donor support: Process single files or entire directories\nRarefaction: Compare repertoires of different sizes fairly","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using RepertoireMetrics\n\n# Read repertoire (lineage by V-J-CDR3)\nrep = read_repertoire(\"sequences.tsv\", VJCdr3Definition(); \n    length_column=:cdr3)\n\n# Compute all metrics\nmetrics = compute_metrics(rep)\nprintln(\"Shannon diversity: \", metrics.shannon_diversity)\nprintln(\"Clonality: \", metrics.clonality)\n\n# Or select specific metrics\nmetrics = compute_metrics(rep, ShannonEntropy() + Clonality() + MeanLength())","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"RepertoireMetrics\")","category":"section"},{"location":"#Important-Considerations","page":"Home","title":"Important Considerations","text":"Before diving in, keep these key points in mind:\n\nSample size matters: Richness and Shannon entropy are sensitive to sequencing depth. Use rarefaction or sample-size-robust metrics (Simpson, Berger-Parker) when comparing samples of different sizes.\nNo single metric tells the whole story: Different metrics capture different aspects of the distribution. Report multiple complementary metrics.\nLineage definition affects results: Whether you use lineage_id, V-J-CDR3, or a custom definition will change your results. Be consistent across analyses.\n\nSee the Metrics page for a quick reference table on which metric to use for which question.","category":"section"},{"location":"#Package-Contents","page":"Home","title":"Package Contents","text":"Pages = [\"quickstart.md\", \"metrics.md\", \"composable.md\", \"api.md\"]\nDepth = 2","category":"section"}]
}
